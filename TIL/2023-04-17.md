
### **1. 오늘 겪은 문제**

**1.  sateless 무상태 vs stateful **
**2.  bearer타입 **
**3.  null 병합 연산자 **
**4.  jwt 인증 흐름 **
**5.  trycatch 서버가 죽는 걸 막기위한 최후의 보루... **

### **2. 해본 시도**
**1. sateless vs stateful**
	-statless와 statless 사이의 장단을 생각해보았다. 서버의 상태에 영향을 받지 않는 다는 것은, 서버가 다운된 상태에도 동작할 수 있다는 것이기 때문에 서비스를 이용하는 측면에서는 좋다고 생각했다. 반대로 stateful은 모든 정보를 서버측에 기록하고 사용하고 보관할 수 있다는 점에서 좀 더 보안의 측면에서 안전할 수 있겠다.
**2. bearer타입**
	 -bearer타입이 뭔지 그냥 몰랐다. 그러니 당연히도 검색을 해봤다.
**3. null 병합 연산자**
	-매번 해당 값이 정의 되지 않아서 undefined로 들어올때, if구문으로 처리하던 것들을 더 쉽게 처리할 수 있겠다.
**4. jwt 인증 흐름**
	-jwt의 인증 흐름에 대해 이해하기 위해서 여러 문서들을 찾아봤다.
**5.  trycatch 서버가 죽는 걸 막기위한 최후의 보루...**
	-하나의 uri요청을 처리하는 구문 안에서 여러개의 응답을 처리하려다 보니 에라가 나왔다. 그래서 try문 안의 try문을 사용하려는 해괴망측한 시도들을 해보았다.
	


### **3. 해결 방법**
1. 서버가 클라이언트의 상태를 보존하지 않기 때문에 클라이언트 쪽에서 비교적 독립적으로 동작 할 수 있기 때문에 앞으로도 더 많이 사용될 것 같다. (클라이언트 서비스의 질이 높은 쪽이 이길테니까)
2. bearer타입은 쉽게 말해 jwt, oauth2.0 과 같은 토큰 기반 인증의 표준으로 인정하는 스키마 형태라고 한다.
3. ?? 이거 디게 유용해보인다 꼭꼭 기억하자
4. 로그인 성공시 토큰을 발급해서 쿠키에 설정해주고, 해당 토큰이 있다면 인정해주는 식의 놀이동산 자유이용권과 같은 구조로 이해하자!
5. trycatch가 에러 핸들링을 위한 구문이라는 것은 알았지만 유효성 처리에 사용되어 버리고 있었다. 기억하자 에러 핸들링을 위한 구문이다. 에러가 발생했을 때, 서버가 죽는 것을 막기 위한 최후의 보루!

### **4. 새롭게 알게 된 점**
-  jwt토큰의 흐름을 이해했고, 인증을 위한 미들웨어를 따로 만들어 사용하니 상태처리 어마 무시하게 편하고 간편했다. 이전에 나는 session과 ejs의 include구문을 통해서 해당 내용을 처리한 기억이 있는데, 진짜 진짜 너무 편한다. 
- undefined로 들어오는 값에 대한 처리로 늘 if문을 늘여쓰는 것 같아 서글펐는데 오늘부러 그 짐 일부를 덜 수 있을 것 같다.
- trycatch 구문은 결국 에러 핸들링을 위한 도구라는 점. 유효성 처리와는 분명 다르다는 사실을 명심하자.


### **5. 오늘 더 효율적으로 일할 수 있었을 것 같은 방법은?**
- 협업을 할 때에는 선제적인 것이 효율성을 높일 수 있는 것 같다. 기다림을 멈추고 먼저 제시하고 시도하는 것을 기본 태도로 삼자.
- 아직 필요한 부분만 효율적으로 짚고 넘어가지 못하고 전체를 훑어야하지 않을까라는 생각에 발목을 잡힐 때가 있다. 미래 생각하다 현재 놓치지 말자.